Chapter 2
	Kernel Space
		Own memory mapping
		Higher processor privilege to memory and operations
		Drivers, modules, kernel code, etc
	User space
		Applications
		Own memory mapping
		Lowest processor privilege
		Can be 'elevated' by calling kernel processes
			Kernel calls can act on behalf of processes and access memory and hardware with kernel privilege
	
	<asm/current.h>
	has a global item, current
		points to *
	<linux/sched.h>
	struct task_struct
		the currently running process that called the kernel code
		allowing the kernel code to access data in use by said process

	ie.
		printk(KERN_INFO "The process is \"%s\" (pid %i)\n",
				curent->comm, current->pid);
		Will print the name and pid of the current process on that core
	
	Kernel has a smaller stack than applications do
	Could be a single 4096 byte page stack
	For this reason, large automatic variables are a bad idea
	Large structures should be dynamically allocated at time of being called as best practice

	Kernel functions with a double underscore at the front of their name are very low level
	These should be used with caution
	__function_that_might_break_something();
	
	Kernel code does not have floating point arithmetic
	
	insmod - links symbols from kernel to module, inits the module, and puts it in memory
	rmmod - undoes all that
	modprobe - checks symbols to check for OTHER MODULE DEPENDENCIES and also inits them
	lsmod - lists current loaded modules /proc/modules /sys/module
	
	modules compiled are linked with vermagic.o to ensure kernel version being linked to is correct
	therefore modules have to be compiled for each kernel version before being loaded
	
	<linux/version.h> contains macros for version testing
	UTS_RELEASE
		expands a string that describes kernel version
	LINUX_VERSION_CORE
		Expands a binary representation of the version
	KERNEL_VERSION(major,minor,release)
		Integer version code from individual parts of a version
		For instance KERNEL_VERSION(5,18,0) for 5.18.0
			would be equal to LINUX_VERSION_CORE output
	
	Best practice: code which requires changes for different versions or platforms should be hidden in a low level header and called by other high level code to simplify development

	Kernel symbol table
		Addresses of global functions and variables used by the kernel
	
	The kernel headerr provides macros for exporting your symbols and keeping namespaces clean
	EXPORT_SYMBOL(symbol_name);
	EXPORT_SYMBOL_GPL(symbol_name);
		Can be used by GPL modules only (Based)
	
	Have to be in every loadable module	
		#include <linux/module.h>
		#include <linux/init.h>
			Init and cleanup functions
	
	Can also include moduleparam.h
		Pass parameters to module when it is loaded

	MODULE_LICENSE("license_name"); ie GPL or "GPL v2" or "Dual BSD/GPL" or "Proprietary"
		All non-licensed modules are assumed proprietary
	MODULE_AUTHOR(); MODULE_DESCRIPTION(); MODULE_VERSION(); module.h has conventions for version numbering
	MODULE_ALIAS(); MODULE_DEVICE_TABLE(); communicate to user space which devices the module supports
		Best practice is to put all MODULE_ declarations at end of file
	
	Initialization introduces drivers, functionality, and abstractions
		static int __init initialization_function(void){}
		module_init(initialization_function);
	Should be static since they will not be accessed outside of file
	__init tells the kernel that this function is only used during initalization
		module loader will drop these functions after init, freeing memory POG
	__initdata is the same for data
	
	__devinit is the same only if the kernel doesn't have hotpluggable devices
	
	Modules register facilities: devices, filesystems, etc
		Kernel registration functions get passed pointers to data structures describing facilities
			The data structure has pointers to the module functions
				Those functions get called by using those pointers
			Usually prefixed with register_
	Exit/cleanup functions UNREGISTER interfaces
		static void __exit cleanup_function(void){}
		module_exit(cleanup_function);
	
		Returns no value, __exit is like __init
			Built-in or non-removable modules ignore __exit and don't load it into memory
	
		Modules without a cleanup cannot be unloaded
	

	Module Parameters can be used on the commandline
		Specify a parameter as follows
		static char *whom = "world";
		static int howmany = 1;
		module_param(howmany, int, S_IRUGO);
		module_param(whom, charp, S_IRUGO);
		
		int, charp(ointer), bool, invbool, long, short, uint, ulong, ushort
		
		Parameters can be a comma separated array
		module_param_array(name,type,num,perm);
			perm is permissions value
		
		Module parameters should always have a default value
		
		S_IRUGO|S_IWUSR Allows root user to change parameter

CHAPTER 3
	scull is a char driver that acts on memory as if it were a device
		scull0-3 are memory areas that are global and persistent
			Kind of like a drive?
		scullpipe0-3 FIFO(first in/out) devices that act like pipes.
		scullsingle, scullpriv, sculluid, scullwuid 
			similar to scull0, but limits when open is permitted
			one process single
			private to each virtual console(or x terminal session) priv
			allow only one user to open at a time, uid returns Device Busy
			wuid uses blocking open
	
	char devices are accessed through names in the filesystem. Device files.
		Usually in /dev/
		ls -l outputs a c for char drivers and b for block devices
		Major numbers in ls -l are drivers, minor numbers are for specific devices
		
	dev_t in <linux/types.h> holds device numbers, 12 bits for major, 20 for minor
	<linux/kdev_t.h> has
		MAJOR(dev_t dev);
		MINOR(dev_t dev);
		MKDEV(int major, int minor);
	<linux/fs.h> has
		int register_chrdev_region(dev_t first, unsigned int count, char *name);
			obtains a device number for a driver
			first is beginning of allocated numbers, count is amount of devices
			name will appear in /proc/devices
	dynamically allocating a major number is as follows
		int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);
	
	To FREE device numbers, do
		void unregister_chrdev_region(dev_t first, unsigned int count);
		Usually done in an exit/cleanup function
	
	Important data structures: file_operations, file, inode

	linux/fs.h also has
		file_operations structure
		which is a collection of function pointers
		Each open file is associated with a set of functions because it has a f_op pointer
		file is considered object and functions considered methods

		f_ops fields
			struct module *owner; points to the module that owns the structure to prevent being unloaded while in use
			module.h has a macro THIS_MODULE to help with this

			loff_t (*llseek) (struct file *, loff_t, int); changes read/write position in a file and returns positive integer of position
				loff_t is long offset of 64 bits or wider.
				negative returns are errors

			ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); retrieves data from a device. returns number of bytes successfully read. Signed size.

			ssize_t (*write) (struct file (, const char __user *, size_t, loff_t *); sends data TO device.

			int (*readdir) (struct file *, void *, filldir_t); is used by filesystems for reading directories and should be null for devices.

			unsigned int (*poll) (struct file *, struct poll_table_struct *); returns a byte map of whether a device read or write will be blocked. If null, it will assume no blocking.
			THERE'S A LOT OF THESE, JUST USE A REFERENCE

		Scull uses only
			owner
			llseek
			read
			write
			ioctl (device specific functions)
			open (just like fopen() in <file.h>, but for devices)
			release

		struct file
			not a FILE pointer
			strictly a kernel structure
			is created on an open call and is passed to all functions that act on the file until close
			after all instanced are closed, the kernel releases the file

			usually called file or filp

			mode_t f_mode; identifies if file is read and/or writeable FMODE_READ and FMODE_WRITE. can be checked in open or ioctl calls

			loff_t f_pos; current position. should not be changed directly in most cases
			unsigned int f_flags; for things like readonly and nonblocking

			also has an f_ops pointer
			struct file_operations *f_op;

		inode
			represents files internally for the kernel
			dev_t i_rdev; contains number of devices when representing device files
			struct cdev *i_cdev; represents char devices. points to a cdev struct.

			unsigned int iminor;or imajor;(struct inode *inode);


		Before kernel can use device operations for char device, it needs a cdev structure
		allocate cdevs as follows
		<linux/cdev.h>
		struct cdev *a_cdev = cdev_alloc();
		a_cdev->ops = &mmy_fops;
			runtime allocation

		or
		void cdev_init(struct cdev *cdev, struct file_operations *fops);
			to embed the cdev in a device specific structure
		cdev's owner field should be set to THIS_MODULE

		int cdev_add(struct cdev *dev, dev_t num, unsigned int count);
			will inform the kernel of the cdev being initialized

		you should not call this until the device is ready to be called upon by other code

		void cdev_del(struct cdev *dev); will remove the char device

	scull represents each device with struct scull_dev
		which has
		struct scull_qset *data; pointer to first quantum set
		int quantum; current quantum size
		int qset; current array size
		unsigned long size; amount of data stored
		unsigned int access_key;
		struct semaphore sem;
		struct cdev cdev;

	static void scull_setup_cdev(struct scull_dev * dev, int index); initializes the cdev member

	stopped page 58

	in <linux/kernel.h>
	container_of(pointer, container_type, container_field);
		to get scull device from cdev inode
		struct scull_dev *dev;

		dev = container_of(inode->i_cdev, struct scull_dev, cdev);
		filp->private_data = dev;

	
